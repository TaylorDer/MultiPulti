# ВИДЫ ОТНОШЕНИЙ МЕЖДУ ОБЪЕКТАМИ

В поле зрения разработчика ПО находятся не объекты-одиночки, а взаимодействующие объекты, ведь именно взаимодействие объектов реализует поведение системы. У Г. Буча есть отличная цитата из Галла: «**Самолет** - это набор элементов, каждый из которых по своей природе стремится упасть на землю, но ценой совместных непрерывных усилий преодолевает эту тенденцию» [11]. Отношения между парой объектов основываются на взаимной информации о разрешённых операциях и ожидаемом поведении. Интересны два вида отношений между объектами: связи и агрегация.

**СВЯЗИ

Связь** - это физическое или понятийное соединение между объектами. Объект сотрудничает с другими объектами через соединяющие их связи. Связь обозначает соединение, с помощью которого: объект-клиент вызывает операции объекта-поставщика; один объект перемещает данные к другому объекту.

Можно сказать, что связи являются рельсами между станциямиобъектами, по которым ездят «трамвайчики сообщений».

![Рис. 2.5. Связи между объектами](/images/milovanov/ris_2_5.jpg)

Рис. 2.5. Связи между объектами

Связи между объектами показаны на рис. 2.5 с помощью соединительных линий. Связи представляют возможные пути для передачи сообщений. Сами сообщения показаны стрелками, отмечающими их направления, и помечены именами вызываемых операций.

Как участник связи, объект может играть одну из трёх ролей:

актёр - объект, который может воздействовать на другие объек-

ты, но никогда не подвержен воздействию других объектов; сервер - объект, который никогда не воздействует на другие объ-

екты, он только используется другими объектами; агент - объект, который может как воздействовать на другие объ-

екты, так и использоваться ими. Агент создаётся для выполнения работы от имени актёра или другого агента.

На рисунке 2.5, **Том** - это актёр, Мери, Колонки - серверы, Музыкальный центр - агент.

Приведём пример. Допустим, что нужно обеспечить следующий график разворота первой ступени ракеты по углу тангажа, представленный на рис. 2.6.

Запишем абстракцию графика разворота: with Класс «ДатчикУглаТангажа»; use Класс «ДатчикУглаТангажа»;

Package Класс «ГрафикРазворота» is subtype Секунда is Natural range ...; type ГрафикРазворота is tagged private; procedure «Очистить» (in out ГрафикРазворота); procedure «Связать» (in out ГрафикРазворота; teta: Угол: si: Секунда: s2: Секунда);

function «УголНаМомент» (ГрафикРазворота; s: Секунда) return Угол;

private

…

end Класс «ГрафикРазворота».

![Рис. 2.6. График разворота первой ступени ракеты](/images/milovanov/ris_2_6.jpg)

Рис. 2.6. График разворота первой ступени ракеты

Для решения задачи надо обеспечить сотрудничество трёх объектов:

экземпляра класса «ГрафикРазворота», «РегуляторУгла» и «Контроллер- Угла».

Описание класса «КонтроллерУгла» может иметь следующий вид:

with Класс «ГрафикРазворота». Класс «РегуляторУгла»; use Класс «ГрафикРазворота». Класс «РегуляторУгла»;

Package Класс «КонтроллерУгла» is type указатель на График is access all ГрафикРазворота; type «КонтроллерУгла» is tagged private; procedure «Обрабатывать» (in out КонтроллерУгла; угол: указатель на График);

function Запланировано (КонтроллерУгла; угол: указатель на График) return Секунда;

private type «КонтроллерУгла» is tagged record; регулятор: РегуляторУгла := Новый РегуляторУгла (1.1.10);

…

end Класс «КонтроллерУгла».

Примечание. Операция «Запланировано» позволяет клиентам запросить у экземпляра «КонтроллерУгла» время обработки следующего графика.

И наконец, описание класса «РегуляторУгла» представим в следующей форме:

with Класс «ДатчикУгла». Класс «Порт»; use Класс «ДатчикУгла». Класс «Порт»; Package Класс «РегуляторУгла» is type Режим is (Увеличение. Уменьшение); subtype Размещение is Natural range ...; type РегуляторУгла is tagged private;

function Новый РегуляторУгла (номер: Размещение; например: Направление: Порт: Порт) return «РегуляторУгла»;

procedure «Включить»(in out РегуляторУгла); procedure «Выключить»(in out РегуляторУгла); procedure «УвеличитьУгол»(in out РегуляторУгла); procedure «УменьшитьУгол»(in out РегуляторУгла); function ОпросСостояния(РегуляторУгла) return Режим:

private type указатель на Порт is access all Порт; type РегуляторУгла is tagged record; Номер: Размещение;

Состояние: Режим;

Управление: указатель на Порт; end record;

end Класс «РегуляторУгла».

Теперь, когда сделаны необходимые приготовления, объявим нужные экземпляры классов, т.е. объекты:

РабочийГрафик: aliased ГрафикРазворота; РабочийКонтроллер: aliased КонтроллерУгла.

Далее мы должны определить конкретные параметры графика разворота: связать (РабочийГрафик. 30. 60. 90);

а затем предложить объекту-контроллеру выполнить этот график: 	обрабатывать (РабочийКонтроллер. РабочийГрафикАссеss);

Рассмотрим отношение между объектом «РабочийГрафик» и объектом «РабочийКонтроллер». **РабочийКонтроллер** - это агент, отвечающий за выполнение графика разворота и поэтому использующий объект «РабочийГрафик» как сервер. В данном отношении объект «РабочийКонтроллер» использует объект «РабочийГрафик» как аргумент в одной из своих операций.