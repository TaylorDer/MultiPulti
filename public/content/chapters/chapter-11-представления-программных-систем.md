# ПРЕДСТАВЛЕНИЯ ПРОГРАММНЫХ СИСТЕМ


Рассмотрение любой сложной системы требует применения техники
декомпозиции - разбиения на составляющие элементы. Известны две
схемы декомпозиции: **алгоритмическая декомпозиция** и объектно-ориен-
тированная декомпозиция.
В основе алгоритмической декомпозиции лежит разбиение по дейст
виям - алгоритмам. Эта схема представления применяется в обычных **ПС**.
**Объектно-ориентированная декомпозиция** обеспечивает разбиение
по автономным лицам - объектам реального (или виртуального) мира.
Эти лица (объекты) - более «крупные» элементы, каждый из них несёт в
себе и описания действий, и описания данных.
Объектно-ориентированное представление **ПС** основывается на
**принципах абстрагирования, инкапсуляции, модульности** и иерархиче
ской организации. Каждый из этих принципов не нов, но их совместное
применение рассчитано на проведение объектно-ориентированной деком
позиции. Это определяет модификацию их содержания и механизмов
взаимодействия друг с другом. Обсудим данные принципы [11], [12], [13],
[14], [15], [16].
**АБСТРАГИРОВАНИЕ**
Аппарат абстракции - удобный инструмент для борьбы со сложно
стью реальных систем. Создавая понятие в интересах какой-либо задачи,
мы отвлекаемся (абстрагируемся) от несущественных характеристик кон
кретных объектов, определяя только существенные характеристики. На
пример, в абстракции «часы» мы выделяем характеристику «показывать
время», отвлекаясь от таких характеристик конкретных часов, как форма,
цвет, материал, цена, изготовитель.
Итак, **абстрагирование** сводится к формированию абстракций. Каж
дая **абстракция** фиксирует основные характеристики объекта, которые
отличают его от других видов объектов и обеспечивают ясные понятий
ные границы.
**Абстракция** концентрирует внимание на внешнем представлении
объекта, позволяет отделить основное в поведении объекта от его реа-
лизации. Абстракцию удобно строить путём выделения обязанностей
объекта.
Пример: физический **объект** - датчик скорости, устанавливаемый
на борту летательного аппарата (ЛА). Создадим его абстракцию. Для это
го сформулируем обязанности датчика:
знать проекцию скорости ЛА в заданном направлении;
показывать текущую скорость;
подвергаться настройке.
Теперь опишем абстракцию датчика. Описание сформулируем как
спецификацию класса:
**класс** «ДатчикСкорости» это
поле «Скорость вещественный» ...;
поле «Направление строковый» ...;
тип «ДатчикСкорости» закрытый;
функция «НовыйДатчик»(Направление);
вернуть «ДатчикСкорости»;
функция «ТекущаяСкорость»(ДатчикСкорости)
вернуть Скорость;
процедура «Настраивать»(ДатчикСкорости;
ДействительнаяСкорость: Скорость);
**класс** «ДатчикСкорости».
Здесь Скорость и Направление - вспомогательные подтипы, обеспе
чивающие задание операций абстракции (НовыйДатчик, ТекущаяСко
рость, Настраивать). Приведённая **абстракция** - это только спецификация
класса датчика, настоящее его представление скрыто в приватной части
спецификации и теле класса. **Класс** «ДатчикСкорости» - ещё не **объект**.
**Собственно датчики** - это его экземпляры, и их нужно создать, прежде
чем с ними можно будет работать. Например, можно написать так:
ДатчикПродольнойСкорости : ДатчикСкорости;
ДатчикПоперечнойСкорости : ДатчикСкорости;
ДатчикНормальнойСкорости : ДатчикСкорости.
**ИНКАПСУЛЯЦИЯ**
**Инкапсуляция** и **абстракция** - взаимодополняющие понятия: абст
ракция выделяет внешнее поведение объекта, а **инкапсуляция** содержит и
скрывает реализацию, которая обеспечивает это поведение. **Инкапсуляция**
достигается с помощью информационной закрытости. Обычно скрывают
ся структура объектов и реализация их методов.
**Инкапсуляция** является процессом разделения элементов абстракции
на секции с различной видимостью. **Инкапсуляция** служит для отделения
интерфейса абстракции от её реализации.
Пример: физический **объект** «Регулятор скорости».
Обязанности регулятора:
включаться;
выключаться;
увеличивать скорость;
уменьшать скорость;
отображать своё состояние.
Спецификация класса «Регулятор скорости» примет вид:
**класс** «ДатчикСкорости». **Класс** «Порт»;
использовать **Класс** «ДатчикСкорости». **Класс** «Порт»;
**класс** «РегуляторСкорости» это
поле «Режим тип» (Увеличение, Уменьшение);
поле «Размещение строковый»;
поле «РегуляторСкорости» закрытое;
фнукция «НовыйРегуляторСкорости» (номер: Размещение;
например: Направление; Порт: Порт);
вернуть «РегуляторСкорости»;
процедура «Включить»(РегуляторСкорости);
процедура «Выключить»(РегуляторСкорости);
процедура «УвеличитьСкорость»(РегуляторСкорости);
процедура «УменьшитьСкорость»(РегуляторСкорости);
функция «OnpocCocтояния»(РегуляторСкорости);
закрытый
поле указатель на Порт доступ Порт;
поле «РегуляторСкорости» запись
Номер; Размещение;
Состояние; Режим;
Управление: указатель на Порт;
конец записи;
конец **Класс** «РегуляторСкорости».
Здесь вспомогательный тип «Режим» используется для задания ос
новного типа класса, **класс** «ДатчикСкорости» обеспечивает **класс** регуля
тора описанием вспомогательного типа «Направление», **класс** «Порт»
фиксирует абстракцию порта, через который посылаются сообщения для
регулятора. Три свойства: Номер, Состояние, Управление - формулируют
инкапсулируемое представление основного типа класса «РегуляторСко
рости». При попытке клиента получить доступ к этим свойствам фикси
руется семантическая ошибка.
Полное инкапсулированное представление класса «РегуляторСкоро
сти» включает описание реализаций его методов - оно содержится в теле
класса. Описание тела для краткости здесь опущено.
**МОДУЛЬНОСТЬ**
В языках C++, Object Pascal абстракции классов и объектов форми
руют логическую структуру системы. При производстве физической
структуры эти абстракции помещаются в модули. В больших системах,
где классов сотни, модули помогают управлять сложностью. Модули
служат физическими контейнерами, в которых объявляются классы и
объекты логической разработки.
**Модульность** определяет способность системы подвергаться деком
позиции на ряд сильно связанных и слабо сцепленных модулей.
Общая цель декомпозиции на модули: уменьшение сроков разработ
ки и стоимости **ПС** за счёт выделения модулей, которые проектируются и
изменяются независимо. Каждая модульная структура должна быть дос
таточно простой, чтобы быть полностью понятой. Изменение реализации
модулей должно проводиться без знания реализации других модулей и без
влияния на их поведение.
Определение классов и объектов выполняется в ходе логической раз
работки, а определение модулей - в ходе физической разработки системы.
Эти действия сильно взаимосвязаны, осуществляются итеративно.