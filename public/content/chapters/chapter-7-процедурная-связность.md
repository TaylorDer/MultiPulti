# ПРОЦЕДУРНАЯ СВЯЗНОСТЬ


При достижении процедурной связности мы попадаем в погранич
ную область между хорошей сопровождаемостью (для модулей с более
высокими уровнями связности) и плохой сопровождаемостью (для моду
лей с более низкими уровнями связности). Процедурно связный **модуль**
состоит из элементов, реализующих независимые действия, для которых
задан порядок работы, т.е. порядок передачи управления. Зависимости по
данным между элементами нет. Например:
**модуль** «Вычисление средних значений»
используется «Таблица-А». «Таблица-В»;
вычислить среднее по «Таблица-А»;
вычислить среднее по «Таблица-В»;
вернуть среднее «Таблица-А». «Таблица-В»;
конец модуля.
Этот **модуль** вычисляет средние значения для двух, полностью не
связанных таблиц «Таблица-А» и «Таблица-В», каждая из которых имеет
по 300 элементов.
Теперь представим себе программиста, которому поручили реализо
вать данный **модуль**. Соблазнившись возможностью минимизации кода
(использовать один цикл в интересах двух обработчиков, ведь они нахо
дятся внутри единого модуля!), программист пишет:
**модуль** «Вычисление средних значений»
используется «Таблица-А». «Таблица-В»;
сумма Таблица-А := 0;
сумма Таблица-В := 0;
для i := 1 до 300;
сумма Таблица-А := сумма Таблица-А + Таблица-А(i);
сумма Таблица-В : = сумма Таблица-В + Таблица-В(i);
конец для
среднее Таблица-А := сумма Таблица-А / 300;
среднее Таблица-В := сумма Таблица-В / 300;
вернуть среднее Таблица-А, среднее Таблица-В;
конец модуля.
Для процедурной связности этот случай типичен - независимый (на
уровне проблемы) код стал зависимым (на уровне реализации). Прошли
годы, продукт сдали заказчику. И вдруг возникла задача сопровождения -
модифицировать **модуль** под уменьшение размера таблицы В. Оцените,
насколько удобно её решать.