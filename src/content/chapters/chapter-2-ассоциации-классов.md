# АССОЦИАЦИИ КЛАССОВ



**Ассоциация** обозначает семантическое соединение классов.
Пример: в системе обслуживания читателей имеются две ключе
вые абстракции – Книга и Библиотека. **Класс** «Книга» играет роль элемен
та, хранимого в библиотеке. **Класс** «Библиотека» играет роль хранилища
для книг.
Отношение ассоциации между классами изображено на рис. 2.10.
Очевидно, что **ассоциация** предполагает двухсторонние отношения:
для данного экземпляра Книги выделяется экземпляр Библиотеки,
обеспечивающий её хранение;
для данного экземпляра Библиотеки выделяются все хранимые
Книги.
Здесь показана **ассоциация** один-ко-многим. Каждый экземпляр Кни
ги имеет указатель на экземпляр Библиотеки. Каждый экземпляр Библио
теки имеет набор указателей на несколько экземпляров Книги.
**Ассоциация** обозначает только семантическую связь. Она не указы
вает направление и точную реализацию отношения. **Ассоциация** пригодна
для анализа проблемы, когда нам требуется лишь идентифицировать свя
зи. С помощью создания ассоциаций мы приводим к пониманию участни
ков семантических связей, их ролей, мощности (количества элементов).
**Ассоциация** один-ко-многим, введённая в примере, означает, что для
каждого экземпляра класса «Библиотека» есть 0 или более экземпляров
класса «Книга», а для каждого экземпляра класса «Книга» есть один эк
земпляр класса «Библиотека». Эту множественность обозначает мощ
ность ассоциации. Мощность ассоциации бывает трёх типов:
один-к-одному;
один-ко-многим;
многие-ко-многим.
Примеры ассоциаций с различными типами мощности приведены на
рис. 2.11, они имеют следующий смысл:
у европейской жены один муж, а у европейского мужа одна жена;
у восточной жены один муж, а у восточного мужа сколько угодно
жён;
Рис. 2.10. **Ассоциация**
Рис. 2.11. Ассоциации с различными типами мощности
у заказа один клиент, а у клиента сколько угодно заказов;
человек может посещать сколько угодно зданий, а в здании может
находиться сколько угодно людей.
**НАСЛЕДОВАНИЕ**
**Наследование** – это отношение, при котором один **класс** разделяет
структуру и поведение, определённые в одном другом (простое наследо
вание) или во многих других (множественное **наследование**) классах.
Между п классами **наследование** определяет иерархию «является»
(«is а»), при которой подкласс наследует от одного или нескольких более
общих суперклассов. Говорят, что подкласс является специализацией его
суперкласса (за счёт дополнения или переопределения существующей
структуры или поведения).
Пример: дана система для записи параметров полёта в «чёрный
ящик», установленный в самолёте. Организуем систему в виде иерархии
классов, построенной на базе наследования. **Абстракция** «верхнего» клас
са иерархии имеет вид:
with ...;...
use ...; ...
Package **Класс** «ПараметрыПолета» is
type «ПараметрыПолета» is tagged private;
function «Инициировать» return «ПараметрыПолета»;
procedure «Записывать» (in out ПараметрыПолета);
function «ТекущееВремя» (ПараметрыПолета)
return «БортовоеВремя»;
private
type «ПараметрыПолета» is tagged record;
Имя: integer;
ОтметкаВремени: БортовоеВремя;
end record;
end **Класс** «ПараметрыПолета».
Запись параметров кабины самолета может обеспечиваться следую
щим классом:
with **Класс** «ПараметрыПолета»;
use **Класс** «ПараметрыПолета»;
Package **Класс** «Кабина» is
type «Кабина» is new «ПараметрыПолета» with private;
function Инициировать (Д:Давление; К:Кислород;
Т:Температура) return «Кабина»;
procedure «Записывать» (in out Кабина);
function «ПерепадДавления» (Кабина) return «Давление»;
private
type «Кабина» is new «ПараметрыПолета»
with record
параметр1: Давление;
параметр2: Кислород;
параметр3: Температура
end record;
end **Класс** «Кабина».
Этот **класс** наследует структуру и поведение класса «ПараметрыПо
лета», но наращивает его структуру (вводит три новых элемента данных),
переопределяет его поведение (процедура «Записывать») и дополняет его
поведение (функция «ПерепадДавления»).
**Иерархическая структура** классов системы для записи параметров
полёта, находящихся в отношении наследования, показана на рис. 2.12.
Здесь «ПараметрыПолета» – базовый (корневой) суперкласс, под
классами которого являются Экипаж, ПараметрыДвижения, Приборы,
Кабина. В свою очередь, **класс** «ПараметрыДвижения» является супер
классом для его подклассов «Координаты», «Скорость», «Ориентация».
Рис. 2.12. Иерархия простого наследования
**ПОЛИМОРФИЗМ**
**Полиморфизм** – возможность с помощью одного имени обозначать
операции из различных классов (но относящихся к общему суперклассу).
Вызов обслуживания по полиморфному имени приводит к исполнению
одной из некоторого набора операций.
Рассмотрим различные реализации процедуры «Записывать». Для
класса «ПараметрыПолета» реализация имеет вид
procedure «Записывать» (in out ПараметрыПолета) is
begin – записывать имя параметра; – записывать отметку времени;
end Записывать.
В классе «Кабина» предусмотрена другая реализация процедуры
procedure Записывать (in out Кабина) is
begin
Записывать (ПараметрыПолета); – вызов метода суперкласса; – записывать значение давления; – записывать процентное содержание кислорода; – записывать значение температуры;
end Записывать.
Предположим, что мы имеем по экземпляру каждого из этих двух
классов:
В полете: ПараметрыПолета:= Инициировать;
В кабине: Кабина:= Инициировать (768. 21. 20);
Предположим также, что имеется свободная процедура:
procedure СохранятьНовыеДанные (d: in out
ПараметрыПолета'class; t: БортовоеВремя) is
begin
if ТекущееВремя(d) >= t then
Записывать (d): – диспетчирование с помощью тега
end if;
end СохранятьНовыеДанные.
Что случится при выполнении следующих операторов?
СохранятьНовыеДанные (Вполете, БортовоеВремя (60));
СохранятьНовыеДанные (Вкабине, БортовоеВремя (120)).
Каждый из операторов вызывает операцию «Записывать» нужного
класса. В первом случае диспетчеризация приведёт к операции «Записы
вать» из класса «ПараметрыПолета». Во втором случае будет выполняться
операция из класса «Кабина». Как видим, в свободной процедуре пере
менная d может обозначать объекты разных классов, значит, здесь запи
сан вызов полиморфной операции.
**АГРЕГАЦИЯ**
Отношения агрегации между классами аналогичны отношениям аг
регации между объектами.
Повторим пример с описанием класса «КонтроллерУгла»:
with **Класс** «ГрафикРазворота». **Класс** «РегуляторУгла»;
use **Класс** «ГрафикРазворота», **Класс** «РегуляторУгла»;
Package **Класс** «КонтроллерУгла» is
type указатель наГрафик is access all ГрафикРазворота;
type КонтроллерУгла is tagged private:
procedure Обрабатывать (in out КонтроллерУгла;
yгол: указатель на График);
function Запланировано (КонтроллерУгла;
угол: указатель на График) return Секунда;
private
type КонтроллерУгла is tagged record;
регулятор: РегуляторУгла;
…
end **Класс** «КонтроллерУгла».
КонтроллерУгла
РегуляторУгла
Рис. 2.13. Отношение агрегации по величине (композиция)
Видим, что **класс** «КонтроллерУгла» является агрегатом, а экземпляр
класса «РегуляторУгла» – это одна из его частей. **Агрегация** здесь опреде
лена как включение по величине. Это пример физического включения,
означающий, что **объект** «Регулятор» не существует независимо от вклю
чающего его экземпляра КонтроллераУгла. Время жизни этих двух объек
тов неразрывно связано.
Графическая иллюстрация отношения агрегации по величине (ком
позиции) представлена на рис. 2.13.
Возможен косвенный тип агрегации – включение по ссылке. Если мы
запишем в приватной части класса «КонтроллерУгла»:
…
private
type указатель на РегуляторУгла is access all РегуляторУгла;
type КонтроллерУгла is tagged record;
регулятор: указатель на РегуляторУгла;
…
end **Класс** «КонтроллерУгла»;
то регулятор как часть контроллера будет доступен косвенно.
Теперь **сцепление** объектов уменьшено. Экземпляры каждого класса
создаются и уничтожаются независимо.
Ещё два примера агрегации по ссылке и по величине (композиции)
приведены на рис. 2.14. Здесь показаны **класс**-агрегат «Дом» и **класс**
агрегат «Окно», причём указаны роли и множественность частей агрегата
(соответствующие пометки имеют линии отношений).
Как показано на рисунке 2.15, возможны и другие формы представ
ления агрегации по величине – композиции. Композицию можно отобра
зить графическим вложением символов частей в символ агрегата (левая
часть рис. 2.15). Вложенные части демонстрируют свою множественность
(мощность, кратность) в правом верхнем углу своего символа. Если метка
множественности опущена, по умолчанию считают, что её значение «мно
го». Вложенный элемент может иметь роль в агрегате. Используется син
таксис
роль : имя Класса.
Рис. 2.14. **Агрегация** классов
Рис. 2.15. Формы представления композиции
Эта роль соответствует той роли, которую играет часть в неявном (в
этой нотации) отношении композиции между частью и целым (агрегатом).
Как представлено в правой части рис. 2.15, свойства (атрибуты)
класса находятся в отношении композиции между всем классом и его
элементами-свойствами. Тем не менее в общем случае свойства должны
иметь примитивные значения (числа, строки, даты), а не ссылаться на
другие классы, так как в «атрибутной» нотации не видны другие отноше
ния классов-частей. Кроме того, свойства классов не могут находиться в
совместном использовании несколькими классами.
**ЗАВИСИМОСТЬ**
**Зависимость** – это отношение, которое показывает, что изменение в
одном классе (независимом) может влиять на другой **класс** (зависимый),
который использует его. Графически **зависимость** изображается как пунк-
Рис. 2.16. Отношение зависимости
тирная стрелка, направленная на **класс**, от которого зависят. С помощью
зависимости уточняют, какая **абстракция** является клиентом, а какая –
поставщиком определённой услуги. Пунктирная стрелка зависимости на
правлена от клиента к поставщику.
Наиболее часто зависимости показывают, что один **класс** использует
другой **класс** как аргумент в сигнатуре своей операции. В предыдущем
примере **класс** «ГрафикРазворота» появляется как аргумент в методах
«Обрабатывать» и «Запланировано» класса «КонтроллерУгла». Поэтому,
как показано на рис. 2.16, КонтроллерУгла зависит от класса «ГрафикРаз
ворота».
**КОНКРЕТИЗАЦИЯ**
В [11] определяется **конкретизация** как процесс наполнения шаблона
(родового или параметризованного класса). Целью является получение
класса, от которого возможно создание экземпляров.
Родовой **класс** служит заготовкой, шаблоном, параметры которого
могут наполняться (настраиваться) другими классами, типами, объектами,
операциями. Он может быть родоначальником большого количества обыч
ных (конкретных) классов. Возможности настройки родового класса пред
ставляются списком формальных родовых параметров. Эти параметры в
процессе настройки должны заменяться фактическими родовыми парамет
рами. Процесс настройки родового класса называют конкретизацией.
В разных языках программирования родовые классы оформляются
по-разному. Воспользуемся возможностями языка, в котором впервые
была реализована идея настройки-параметризации. Здесь формальные
родовые параметры записываются между словом generic и заголовком
пакета, размещающего **класс**.
Пример: представим родовой (параметризированный) **класс**
«Очередь»:
generic
type Элемент is private;
package **Класс** «Очередь» is
type Очередь is limited tagged private;
…
procedure Добавить (В Очередь: in out Очередь;
элемент: Элемент);
…
private
…
end **Класс** «Очередь».
У этого класса один формальный родовой параметр – тип «Элемент».
Вместо этого параметра можно подставить почти любой тип данных.
Произведём настройку, т.е. объявим два конкретизированных класса –
«ОчередьЦелыхЭлементов» и «ОчередьЛилипутов»:
package **Класс** «ОчередьЦелыхЭлементов» is new **Класс** «Очередь»
(Элемент => Integer);
package **Класс** «ОчередьЛилипутов» is new **Класс** «Очередь»
(Элемент => Лилипут).
В первом случае мы настраивали **класс** на конкретный тип «Integer»
(фактический родовой параметр), во втором случае – на конкретный тип
«Лилипут».
Классы «ОчередьЦелыхЭлементов» и «ОчередьЛилипутов» можно
использовать как обычные классы. Они содержат все средства родового
класса, но только эти средства настроены на использование конкретного
типа, заданного при конкретизации.
Графическая иллюстрация отношений конкретизации приведена на
рис. 2.17. Отметим, что отношение конкретизации отображается с помо
щью подписанной стрелки отношения зависимости. Это логично, по
скольку конкретизированный **класс** зависит от родового класса (класса
шаблона).
**Класс** «Очередь»
**Класс** «ОчередьЦелыхЭлементов»
**Класс** «ОчередьЛилипутов»
Рис. 2.17. Отношения конкретизации родового класса