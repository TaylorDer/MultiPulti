# ВИДЫ ОТНОШЕНИЙ МЕЖДУ ОБЪЕКТАМИ


В поле зрения разработчика ПО находятся не объекты-одиночки, а
взаимодействующие объекты, ведь именно взаимодействие объектов реа
лизует поведение системы. У Г. Буча есть отличная цитата из Галла: «**Са
молет** – это набор элементов, каждый из которых по своей природе стре
мится упасть на землю, но ценой совместных непрерывных усилий пре
одолевает эту тенденцию» [11]. Отношения между парой объектов осно
вываются на взаимной информации о разрешённых операциях и ожидае
мом поведении. Интересны два вида отношений между объектами: связи
и **агрегация**.
**СВЯЗИ
Связь** – это физическое или понятийное соединение между объекта
ми. **Объект** сотрудничает с другими объектами через соединяющие их
связи. Связь обозначает соединение, с помощью которого:
**объект**-клиент вызывает операции объекта-поставщика;
один **объект** перемещает данные к другому объекту.
Можно сказать, что связи являются рельсами между станциями
объектами, по которым ездят «трамвайчики сообщений».
Актёр
Сервер
Сервер
Актёр
Рис. 2.5. Связи между объектами
Связи между объектами показаны на рис. 2.5 с помощью соедини
тельных линий. Связи представляют возможные пути для передачи сооб
щений. Сами сообщения показаны стрелками, отмечающими их направ
ления, и помечены именами вызываемых операций.
Как участник связи, **объект** может играть одну из трёх ролей:
актёр – **объект**, который может воздействовать на другие объек
ты, но никогда не подвержен воздействию других объектов;
сервер – **объект**, который никогда не воздействует на другие объ
екты, он только используется другими объектами;
агент – **объект**, который может как воздействовать на другие объ
екты, так и использоваться ими. Агент создаётся для выполнения работы
от имени актёра или другого агента.
На рисунке 2.5, **Том** – это актёр, Мери, Колонки – серверы, Музы
кальный центр – агент.
Приведём пример. Допустим, что нужно обеспечить следующий
график разворота первой ступени ракеты по углу тангажа, представлен
ный на рис. 2.6.
Запишем абстракцию графика разворота:
with **Класс** «ДатчикУглаТангажа»;
use **Класс** «ДатчикУглаТангажа»;
Package **Класс** «ГрафикРазворота» is
subtype Секунда is Natural range ...;
type ГрафикРазворота is tagged private;
procedure «Очистить» (in out ГрафикРазворота);
procedure «Связать» (in out ГрафикРазворота;
teta: Угол: si: Секунда: s2: Секунда);
function «УголНаМомент» (ГрафикРазворота;
s: Секунда) return Угол;
private
…
end **Класс** «ГрафикРазворота».
Рис. 2.6. График разворота первой ступени ракеты
Для решения задачи надо обеспечить сотрудничество трёх объектов:
экземпляра класса «ГрафикРазворота», «РегуляторУгла» и «Контроллер-
Угла».
Описание класса «КонтроллерУгла» может иметь следующий вид:
with **Класс** «ГрафикРазворота». **Класс** «РегуляторУгла»;
use **Класс** «ГрафикРазворота». **Класс** «РегуляторУгла»;
Package **Класс** «КонтроллерУгла» is
type указатель на График is access all ГрафикРазворота;
type «КонтроллерУгла» is tagged private;
procedure «Обрабатывать» (in out КонтроллерУгла;
угол: указатель на График);
function Запланировано (КонтроллерУгла;
угол: указатель на График) return Секунда;
private
type «КонтроллерУгла» is tagged record;
регулятор: РегуляторУгла := Новый РегуляторУгла (1.1.10);
…
end **Класс** «КонтроллерУгла».
Примечание. Операция «Запланировано» позволяет клиентам запро
сить у экземпляра «КонтроллерУгла» время обработки следующего графика.
И наконец, описание класса «РегуляторУгла» представим в следую
щей форме:
with **Класс** «ДатчикУгла». **Класс** «Порт»;
use **Класс** «ДатчикУгла». **Класс** «Порт»;
Package **Класс** «РегуляторУгла» is
type Режим is (Увеличение. Уменьшение);
subtype Размещение is Natural range ...;
type РегуляторУгла is tagged private;
function Новый РегуляторУгла (номер: Размещение;
например: Направление: Порт: Порт)
return «РегуляторУгла»;
procedure «Включить»(in out РегуляторУгла);
procedure «Выключить»(in out РегуляторУгла);
procedure «УвеличитьУгол»(in out РегуляторУгла);
procedure «УменьшитьУгол»(in out РегуляторУгла);
function ОпросСостояния(РегуляторУгла)
return Режим:
private
type указатель на Порт is access all Порт;
type РегуляторУгла is tagged record;
Номер: Размещение;
Состояние: Режим;
Управление: указатель на Порт;
end record;
end **Класс** «РегуляторУгла».
Теперь, когда сделаны необходимые приготовления, объявим нуж
ные экземпляры классов, т.е. объекты:
РабочийГрафик: aliased ГрафикРазворота;
РабочийКонтроллер: aliased КонтроллерУгла.
Далее мы должны определить конкретные параметры графика разво
рота:
связать (РабочийГрафик. 30. 60. 90);
а затем предложить объекту-контроллеру выполнить этот график:
обрабатывать (РабочийКонтроллер. РабочийГрафикАссеss);
Рассмотрим отношение между объектом «РабочийГрафик» и объек
том «РабочийКонтроллер». **РабочийКонтроллер** – это агент, отвечающий
за выполнение графика разворота и поэтому использующий **объект** «Ра
бочийГрафик» как сервер. В данном отношении **объект** «РабочийКон
троллер» использует **объект** «РабочийГрафик» как аргумент в одной из
своих операций.