# СПИРАЛЬНАЯ МОДЕЛЬ

**Спиральная модель** - классический пример применения эволюционной стратегии конструирования.

**Спиральная модель** (автор Барри Боэм, 1988) базируется на лучших свойствах классического жизненного цикла и макетирования, к которым добавляется новый элемент - анализ риска, отсутствующий в этих парадигмах [22].

Как показано на рисунке 4.6, модель определяет четыре действия, представляемые четырьмя квадрантами спирали.

Планирование - определение целей, вариантов и ограничений.

Анализ риска - анализ вариантов и распознавание/выбор риска.

Конструирование - разработка продукта следующего уровня.

Оценивание - оценка заказчиком текущих результатов конструирования.

Интегрирующий аспект спиральной модели очевиден при учёте радиального измерения спирали. С каждой итерацией по спирали (продвижением от центра к периферии) строятся всё более полные версии ПО.

В первом витке спирали определяются начальные цели, варианты и ограничения, распознаётся и анализируется риск. Если анализ риска показывает неопределённость требований, на помощь разработчику и заказчику приходит макетирование (используемое в квадранте конструирования).

Рис. 4.6. **Спиральная модель**:

1 - начальный сбор требований и планирование проекта; 2 - та же работа, но на основе рекомендаций заказчика; 3 - анализ риска на основе начальных требований; 4 - анализ риска на основе реакции заказчика; 5 - переход к

комплексной системе; 6 - начальный макет системы; 7 - следующий уровень макета; 8 - сконструированная система; 9 - оценивание заказчиком

Для дальнейшего определения проблемных и уточнённых требований может быть использовано моделирование. Заказчик оценивает инженерную (конструкторскую) работу и вносит предложения по модификации (квадрант оценки заказчиком). Следующая фаза планирования и анализа риска базируется на предложениях заказчика. В каждом цикле по спирали результаты анализа риска формируются в виде «продолжать, не продолжать». Если риск слишком велик, проект может быть остановлен.

В большинстве случаев движение по спирали продолжается, с каждым шагом продвигая разработчиков к более общей модели системы. В каждом цикле по спирали требуется конструирование (нижний правый квадрант), которое может быть реализовано классическим жизненным циклом или макетированием. Заметим, что количество действий по разработке (происходящих в правом нижнем квадранте) возрастает по мере продвижения от центра спирали.

Достоинства спиральной модели:

наиболее реально (в виде эволюции) отображает разработку программного обеспечения;

позволяет явно учитывать риск на каждом витке эволюции разработки;

включает шаг системного подхода в итерационную структуру разработки;

использует моделирование для уменьшения риска и совершенствования программного изделия.

Недостатки спиральной модели:

новизна (отсутствует достаточная статистика эффективности модели);

повышенные требования к заказчику;

трудности контроля и управления временем разработки.

**КОМПОНЕНТНО-ОРИЕНТИРОВАННАЯ МОДЕЛЬ**

**Компонентно-ориентированная модель** является развитием спиральной модели и тоже основывается на эволюционной стратегии конструирования. В этой модели конкретизируется содержание квадранта конструирования - оно отражает тот факт, что в современных условиях новая разработка должна основываться на повторном использовании существующих программных компонентов (рис. 4.7).

Рис. 4.7. **Компонентно-ориентированная модель**

Программные компоненты, созданные в реализованных программных проектах, хранятся в библиотеке. В новом программном проекте, исходя из требований заказчика, выявляются кандидаты в компоненты. Далее проверяется наличие этих кандидатов в библиотеке. Если они найдены, то компоненты извлекаются из библиотеки и используются повторно. В противном случае создаются новые компоненты, они применяются в проекте и включаются в библиотеку.

Достоинства компонентно-ориентированной модели:

1) уменьшает на 30% время разработки программного продукта; 2) уменьшает стоимость программной разработки до 70%; 3) увеличивает в полтора раза производительность разработки.

ТЯЖЕЛОВЕСНЫЕ И ОБЛЕГЧЁННЫЕ ПРОЦЕССЫ

Традиционно для упорядочения и ускорения программных разработок предлагались строго упорядочивающие тяжеловесные (heavyweight) процессы. В этих процессах прогнозируется весь объём предстоящих работ, поэтому они называются прогнозирующими (predictive) процессами. Порядок, который должен выполнять при этом человек-разработчик, чрезвычайно строг.

В последние годы появилась группа новых, облегчённых

(lightweight) процессов [23]. Теперь их называют подвижными (agile) процессами. Они привлекательны отсутствием бюрократизма, характерного для тяжеловесных (прогнозирующих) процессов. Новые процессы должны воплотить в жизнь разумный компромисс между слишком строгой дисциплиной и полным её отсутствием. Иначе говоря, порядка в процессах разработки достаточно для того, чтобы получить разумную отдачу от разработчиков.

Подвижные процессы требуют меньшего объёма документации и ориентированы на человека. В них явно указано на необходимость использования природных качеств человеческой натуры (а не на применение действий, направленных наперекор этим качествам).

Более того, подвижные процессы учитывают особенности современного заказчика, а именно частые изменения его требований к программному продукту. Известно, что для прогнозирующих процессов частые изменения требований подобны смерти. В отличие от них, подвижные процессы адаптируют изменения требований и даже выигрывают от этого. Словом, подвижные процессы имеют адаптивную природу.

Таким образом, в современной инфраструктуре программной инженерии существуют два семейства процессов разработки:

семейство прогнозирующих (тяжеловесных) процессов; семейство адаптивных (подвижных, облегчённых) процессов.

У каждого семейства есть свои достоинства, недостатки и область применения:

адаптивный процесс используют при частых изменениях требований, малочисленной группе высококвалифицированных разработчиков и грамотном заказчике, который согласен участвовать в разработке; прогнозирующий процесс применяют при фиксированных требо-

ваниях и многочисленной группе разработчиков разной квалификации.

**ХР-ПРОЦЕСС**

Экстремальное программирование (eXtreme Programming, XP) - облегчённый (подвижный) процесс (или методология) [24]. **ХР-процесс** ориентирован на группы малого и среднего размера, строящие программное обеспечение в условиях неопределенных или быстро изменяющихся требований. ХР-группу образуют до 10 сотрудников, которые размещаются в одном помещении.

Основная идея ХР - устранить высокую стоимость изменения, характерную для приложений с использованием объектов, паттернов* и реляционных баз данных. Поэтому **ХР-процесс** должен быть высокодинамичным процессом. ХР-группа имеет дело с изменениями требований на всём протяжении итерационного цикла разработки, причём цикл состоит из очень коротких итераций. Четырьмя базовыми действиями в ХР-цикле являются: кодирование, тестирование, выслушивание заказчика и проектирование. Динамизм обеспечивается с помощью четырёх характеристик: непрерывной связи с заказчиком (и в пределах группы), простоты (всегда выбирается минимальное решение), быстрой обратной связи (с помощью модульного и функционального тестирования), смелости в проведении профилактики возможных проблем.

Большинство принципов, поддерживаемых в ХР (минимальность, простота, эволюционный цикл разработки, малая длительность итерации, участие пользователя, оптимальные стандарты кодирования и т.д.), продиктованы здравым смыслом и применяются в любом упорядоченном процессе. Просто в ХР эти принципы, как показано в табл. 4.2, достигают «экстремальных значений».

4.2. Экстремумы в экстремальном программировании

Тот, кто принимает принцип «минимального решения» за хакерство, ошибается, в действительности ХР - строго упорядоченный процесс. Простые решения, имеющие высший приоритет, в настоящее время рассматриваются как наиболее ценные части системы, в отличие от проектных решений, которые пока не нужны, а могут (в условиях изменения требований и операционной среды) и вообще не понадобиться.

Базис ХР образуют перечисленные ниже двенадцать методов.

Игра планирования (Planning game) - быстрое определение области действия следующей реализации путём объединения деловых приоритетов и технических оценок. Заказчик формирует область действия, приоритетность и сроки с точки зрения бизнеса, а разработчики оценивают и прослеживают продвижение (прогресс).

Частая смена версий (Small releases) - быстрый запуск в производство простой системы. Новые версии реализуются в очень коротком (двухнедельном) цикле.

Метафора (Metaphor) - вся разработка проводится на основе простой, общедоступной истории о том, как работает вся система.

Простое проектирование (Simple design) - проектирование выполняется настолько просто, насколько это возможно в данный момент.

Тестирование (Testing) - непрерывное написание тестов для модулей, которые должны выполняться безупречно; заказчики пишут тесты для демонстрации законченности функций. «Тестируй, а затем кодируй» означает, что входным критерием для написания кода является «отказавший» тестовый вариант.

Реорганизация (Refactoring) - система реструктурируется, но её поведение не изменяется; цель - устранить дублирование, улучшить взаимодействие, упростить систему или добавить в неё гибкость.

Парное программирование (Pair programming) - весь код пишется двумя программистами, работающими на одном компьютере.

Коллективное владение кодом (Collective ownership) - любой разработчик может улучшать любой код системы в любое время.

Непрерывная интеграция (Continuous integration) - система интегрируется и строится много раз в день по мере завершения каждой задачи. Непрерывное регрессионное тестирование, т.е. повторение предыдущих тестов гарантирует, что изменения требований не приведут к регрессу функциональности.

40-часовая неделя (40-hour week) - как правило, работают не более 40 часов в неделю. Нельзя удваивать рабочую неделю за счёт сверхурочных работ.

Локальный заказчик (On-site customer) - в группе всё время должен находиться представитель заказчика, действительно готовый отвечать на вопросы разработчиков.

Стандарты кодирования (Coding standards) - должны выдерживаться правила, обеспечивающие одинаковое представление программного кода во всех частях программной системы.

Игра планирования и частая смена версий зависят от заказчика, обеспечивающего набор «историй» (коротких описаний), характеризующих работу, которая будет выполняться для каждой версии системы. Версии генерируются каждые две недели, поэтому разработчики и заказчик должны прийти к соглашению о том, какие истории будут осуществлены в пределах двух недель. Полную функциональность, требуемую заказчику, характеризует пул историй; но для следующей двухнедельной итерации из пула выбирается подмножество историй, наиболее важное для заказчика. В любое время в пул могут быть добавлены новые истории, таким образом, требования могут быстро изменяться. Однако процессы двухнедельной генерации основаны на наиболее важных функциях, входящих в текущий пул, следовательно, изменчивость управляется. Локальный заказчик обеспечивает поддержку этого стиля итерационной разработки.

«Метафора» обеспечивает глобальное «видение» проекта. Она могла бы рассматриваться как высокоуровневая архитектура, но ХР подчёркивает желательность проектирования при минимизации проектной документации. Точнее говоря, ХР предлагает непрерывное перепроектирование (с помощью реорганизации), при котором нет нужды в детализированной проектной документации, а для инженеров сопровождения единственным надёжным источником информации является программный код. Обычно после написания кода проектная документация выбрасывается. Проектная документация сохраняется только в том случае, когда заказчик временно теряет способность придумывать новые истории. Тогда систему помещают в «нафталин» и пишут руководство страниц на пять-десять по «нафталиновому» варианту системы. Использование реорганизации приводит к реализации простейшего решения, удовлетворяющего текущую потребность. Изменения в требованиях заставляют отказываться от всех «общих решений».

Парное программирование - один из наиболее спорных методов в ХР, оно влияет на ресурсы, что важно для менеджеров, решающих, будет ли проект использовать ХР. Может показаться, что парное программирование удваивает ресурсы, но исследования доказали: парное программирование приводит к повышению качества и уменьшению времени цикла. Для согласованной группы затраты увеличиваются на 15%, а время цикла сокращается на 40…50%. Для Интернет-среды увеличение скорости продаж покрывает повышение затрат. Сотрудничество улучшает процесс решения проблем, улучшение качества существенно снижает затраты сопровождения, которые превышают стоимость дополнительных ресурсов по всему циклу разработки.

Коллективное владение означает, что любой разработчик может изменять любой фрагмент кода системы в любое время. Непрерывная интеграция, непрерывное регрессионное тестирование и парное программирование ХР обеспечивают защиту от возникающих при этом проблем.

«Тестируй, а затем кодируй» - эта фраза выражает акцент ХР на тестировании. Она отражает принцип, по которому сначала планируется тестирование, а тестовые варианты разрабатываются параллельно анализу требований, хотя традиционный подход состоит в тестировании «чёрного ящика». Размышление о тестировании в начале цикла жизни - хорошо известная практика конструирования ПО (правда, редко осуществляемая практически).

Основным средством управления ХР является метрика, а среда метрик - «большая визуальная диаграмма». Обычно используют 3-4 метрики, причём такие, которые видимы всей группе. Рекомендуемой в ХР метрикой является «скорость проекта» - количество историй заданного размера, которые могут быть реализованы в итерации.

При принятии ХР рекомендуется осваивать его методы по одному, каждый раз выбирая метод, ориентированный на самую трудную проблему группы. Конечно, все эти методы являются «не более чем правилами» - группа может в любой момент поменять их (если её сотрудники достигли принципиального соглашения по поводу внесённых изменений). Защитники ХР признают, что ХР оказывает сильное социальное воздействие, и не каждый может принять его. Вместе с тем, ХР - это методология, обеспечивающая преимущества только при использовании законченного набора базовых методов.

Рассмотрим структуру «идеального» **ХР-процесс**а. Основным структурным элементом процесса является ХР-реализация, в которую многократно вкладывается базовый элемент - ХР-итерация. В состав ХР-реали- зации и ХР-итерации входят три фазы - исследование, блокировка, регулирование. Исследование (exploration) - это поиск новых требований (историй, задач), которые должна выполнять система. Блокировка (commitment) - выбор для реализации конкретного подмножества из всех возможных требований (иными словами, планирование). Регулирование

(steering) - проведение разработки, воплощение плана в жизнь.

ХР рекомендует: первая реализация должна иметь длительность

- 6 месяцев, продолжительность остальных реализаций - около двух

Рис. 4.8. Идеальный **ХР-процесс**

месяцев, каждая итерация длится приблизительно две недели, а численность группы разработчиков не превышает 10 человек. **ХР-процесс** для проекта с семью реализациями, осуществляемый за 15 месяцев, показан на рис. 4.8.

Процесс инициируется начальной исследовательской фазой.

Фаза исследования, с которой начинается любая реализация и итерация, имеет клапан «пропуска», на этой фазе принимается решение о целесообразности дальнейшего продолжения работы.

Предполагается, что длительность первой реализации составляет

месяца, длительность второй - седьмой реализаций - 2 месяца. Вторая - седьмая реализации образуют период сопровождения, характеризующий природу ХР-проекта. Каждая итерация длится две недели, за исключением тех, которые относят к поздней стадии реализации - «запуску в производство» (в это время темп итерации ускоряется).

Наиболее трудна первая реализация - пройти за три месяца от обычного старта (скажем, отдельный сотрудник не зафиксировал никаких требований, не определены ограничения) к поставке заказчику системы промышленного качества.